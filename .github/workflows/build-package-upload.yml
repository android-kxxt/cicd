# Build, Package and Upload the Release for a single target
name: Build, Package and Upload
run-name: ${{ inputs.manual && 'Manual' || 'Automated' }} OTA build for ${{ inputs.target }} (${{ inputs.unsigned && 'Test-Keys' || '' }}${{ (inputs.sign && inputs.unsigned) && 'Release-Keys' || '' }}${{ inputs.sign && 'Release-Keys' || '' }}${{ (!inputs.sign && !inputs.unsigned) && 'Build Check' || '' }})
on:
  # Stupid GitHub Actions does not allow workflow dispatch and call to share inputs.
  workflow_dispatch:
    inputs:
      top-dir:
        required: true
        type: string
      target:
        required: true
        type: string
      sign:
        description: Create signed release
        required: false
        type: boolean
        default: false
      unsigned:
        description: Create unsigned release
        required: false
        type: boolean
        default: true
      backup:
        required: false
        type: boolean
        default: false
      ota-size-limit:
        required: false
        type: number
        default: 2147483648
      manual:
        description: 'An indicator for maunal invocation'
        type: boolean
        required: false
        default: true
  workflow_call:
    inputs:
      top-dir:
        required: true
        type: string
      target:
        required: true
        type: string
      sign:
        description: Create signed release
        required: false
        type: boolean
        default: false
      unsigned:
        description: Create unsigned release
        required: false
        type: boolean
        default: true
      backup:
        required: false
        type: boolean
        default: false
      ota-size-limit:
        required: false
        type: number
        default: 2147483648
jobs:
  info:
    name: Gather Source Information
    runs-on: self-hosted
    # We don't need to run this on build tests
    if: ${{ inputs.sign || inputs.unsigned }}
    outputs:
      manifests-branch: ${{ steps.repo-info.outputs.manifests-branch }}
      manifests-commit: ${{ steps.repo-info.outputs.manifests-commit }}
      local-branch: ${{ steps.repo-info.outputs.local-branch }}
      local-commit: ${{ steps.repo-info.outputs.local-commit }}
      tree-status: ${{ steps.tree-info.outputs.tree-status }}
    steps:
      - id: repo-info
        name: Get Info about Repo
        run: |
          cd -- "${{ inputs.top-dir }}"
          repo_remote_ref() {
            git -C "$1" for-each-ref --format='%(upstream:short)' "$(git -C "$1" symbolic-ref -q HEAD)"
          }
          repo_remote() {
            git -C "$1" config branch."$(git -C "$1" name-rev --name-only HEAD)".remote
          }
          repo_commit() {
            git -C "$1" rev-parse --short=12 HEAD
          }
          MANIFESTS_REMOTE_REF="$(repo_remote_ref .repo/manifests)"
          MANIFESTS_REMOTE="$(repo_remote .repo/manifests)"
          MANIFESTS_TRACKING_BRANCH="${MANIFESTS_REMOTE_REF#"$MANIFESTS_REMOTE/"}"
          LOCAL_REMOTE_REF="$(repo_remote_ref .repo/local_manifests)"
          LOCAL_REMOTE="$(repo_remote .repo/local_manifests)"
          LOCAL_TRACKING_BRANCH="${LOCAL_REMOTE_REF#"$LOCAL_REMOTE/"}"
          echo "manifests-branch=$MANIFESTS_TRACKING_BRANCH" >> "$GITHUB_OUTPUT"
          echo "manifests-commit=$(repo_commit .repo/manifests)" >> "$GITHUB_OUTPUT"
          echo "local-branch=$LOCAL_TRACKING_BRANCH" >> "$GITHUB_OUTPUT"
          echo "local-commit=$(repo_commit .repo/local_manifests)" >> "$GITHUB_OUTPUT"
      - id: tree-info
        name: Get Tree Status
        run: |
          cd -- "${{ inputs.top-dir }}"
          # Get status of each repo
          {
            echo 'tree-status<<TREE-STATUS-EOF'
            repo forall -c 'echo -n "$REPO_PATH: "; git rev-parse --short=12 m/${{ steps.repo-info.outputs.manifests-branch }}' || true
            echo TREE-STATUS-EOF
          } >> "$GITHUB_OUTPUT"

  build:
    name: Build Target Files Package
    runs-on: self-hosted
    outputs:
      target-files-package: ${{ steps.build.outputs.target-files-package }}
      ANDROID_PRODUCT_OUT: ${{ steps.build.outputs.ANDROID_PRODUCT_OUT }}
      TARGET_PRODUCT: ${{ steps.build.outputs.TARGET_PRODUCT }}
      LINEAGE_BUILD: ${{ steps.build.outputs.LINEAGE_BUILD }}
      PRODUCT_VERSION_MAJOR: ${{ steps.build.outputs.PRODUCT_VERSION_MAJOR }}
      PRODUCT_VERSION_MINOR: ${{ steps.build.outputs.PRODUCT_VERSION_MINOR }}
    steps:
      - name: Build
        id: build
        run: |
          cd -- "${{ inputs.top-dir }}"
          source build/envsetup.sh
          breakfast "${{ inputs.target }}"
          mka target-files-package otatools
          mkdir -p dist
          TARGET_FILES_PACKAGE="dist/$TARGET_PRODUCT-target_files.zip"
          cp "$ANDROID_PRODUCT_OUT/obj/PACKAGING/target_files_intermediates/$TARGET_PRODUCT-target_files.zip" \
            "$TARGET_FILES_PACKAGE"
          echo "target-files-package=$TARGET_FILES_PACKAGE" >> "$GITHUB_OUTPUT"
          echo "ANDROID_PRODUCT_OUT=$ANDROID_PRODUCT_OUT" >> "$GITHUB_OUTPUT"
          echo "TARGET_PRODUCT=$TARGET_PRODUCT" >> "$GITHUB_OUTPUT"
          echo "LINEAGE_BUILD=$LINEAGE_BUILD" >> "$GITHUB_OUTPUT"
          PRODUCT_VERSION_MAJOR=$(grep '^PRODUCT_VERSION_MAJOR' vendor/lineage/config/version.mk | awk -F ' = ' '{print $2}')
          echo "PRODUCT_VERSION_MAJOR=$PRODUCT_VERSION_MAJOR" >> "$GITHUB_OUTPUT"
          PRODUCT_VERSION_MINOR=$(grep '^PRODUCT_VERSION_MINOR' vendor/lineage/config/version.mk | awk -F ' = ' '{print $2}')
          echo "PRODUCT_VERSION_MINOR=$PRODUCT_VERSION_MINOR" >> "$GITHUB_OUTPUT"

  package-ota:
    needs: build
    name: Package OTA (Test-Keys)
    runs-on: self-hosted
    if: ${{ inputs.unsigned }}
    outputs:
      ota: ${{ steps.rename.outputs.ota }}
      BUILD_DATE_UTC_TIMESTAMP: ${{ steps.build.outputs.BUILD_DATE_UTC_TIMESTAMP }}
      BUILD_DATE: ${{ steps.build.outputs.BUILD_DATE }}
      BUILD_ID: ${{ steps.build.outputs.BUILD_ID }}
      SECURITY_PATCH: ${{ steps.build.outputs.SECURITY_PATCH }}
    steps:
      - name: Build OTA
        id: build
        run: |
          cd -- "${{ inputs.top-dir }}"
          source build/envsetup.sh
          breakfast "${{ inputs.target }}"
          mkdir -p dist
          mka dist DIST_DIR=dist
          # Credit: https://gitlab.com/cupid-development/automated-builds/-/blob/main/build.sh
          SECURITY_PATCH="$(cat "$OUT/system/build.prop" | grep ro.build.version.security_patch=)"
          SECURITY_PATCH="${SECURITY_PATCH#*=}"
          echo "SECURITY_PATCH=$SECURITY_PATCH" >> "$GITHUB_OUTPUT"
          BUILD_DATE_UTC_TIMESTAMP="$(cat "$OUT/system/build.prop" | grep ro.build.date.utc=)"
          BUILD_DATE_UTC_TIMESTAMP="${BUILD_DATE_UTC_TIMESTAMP#*=}"
          echo "BUILD_DATE_UTC_TIMESTAMP=$BUILD_DATE_UTC_TIMESTAMP" >> "$GITHUB_OUTPUT"
          BUILD_DATE="$(date -u --date=@"$BUILD_DATE_UTC_TIMESTAMP" +%Y-%m-%d-%H-%M-%S)"
          echo "BUILD_DATE=$BUILD_DATE" >> "$GITHUB_OUTPUT"
          BUILD_ID=$(cat "$OUT/system/build.prop" | grep ro.build.id=)
          BUILD_ID="${BUILD_ID#*=}"
          echo "BUILD_ID=$BUILD_ID" >> "$GITHUB_OUTPUT"
      - name: Rename
        id: rename
        run: |
          cd -- "${{ inputs.top-dir }}"
          FILENAME_WITHOUT_EXTENSION="lineage-${{ needs.build.outputs.PRODUCT_VERSION_MAJOR }}.${{ needs.build.outputs.PRODUCT_VERSION_MINOR }}-${{ steps.build.outputs.BUILD_DATE }}-UNOFFICIAL-${{ needs.build.outputs.LINEAGE_BUILD }}"
          ota="dist/$FILENAME_WITHOUT_EXTENSION.zip"
          mv "dist/${{ needs.build.outputs.TARGET_PRODUCT }}-ota-$USER.zip" "$ota"
          echo "ota=$ota" >> "$GITHUB_OUTPUT"

  create-release:
    needs: [info, build, package-ota]
    name: Create Release (Test-Keys)
    runs-on: self-hosted
    env:
      GH_TOKEN: ${{ github.token }}
    outputs:
      tag: ${{ steps.create-release.outputs.tag }}
    steps:
      - name: Create GitHub Release
        id: create-release
        run: |
          # Create the Release first.
          # Retry the upload in case of network failure.
          release_tag="${{ inputs.target }}-${{ needs.package-ota.outputs.BUILD_DATE }}-test"
          echo "tag=$release_tag" >> "$GITHUB_OUTPUT"
          version="${{ needs.build.outputs.PRODUCT_VERSION_MAJOR }}.${{ needs.build.outputs.PRODUCT_VERSION_MINOR }}"
          gh -R "$GITHUB_REPOSITORY" release create "$release_tag" \
              -t "${{ needs.package-ota.outputs.BUILD_DATE }} Nightly $version OTA for ${{ inputs.target }}" \
              --notes "OS Version: ${{ needs.build.outputs.PRODUCT_VERSION_MAJOR }}.${{ needs.build.outputs.PRODUCT_VERSION_MINOR }}
          Signed With: Test-Keys
          Security Patch: ${{ needs.package-ota.outputs.SECURITY_PATCH }}
          Build ID: ${{ needs.package-ota.outputs.BUILD_ID }}
          Build Timestamp: ${{ needs.package-ota.outputs.BUILD_DATE_UTC_TIMESTAMP }}
          Product: ${{ needs.build.outputs.TARGET_PRODUCT }}
          Manifests Branch: ${{ needs.info.outputs.manifests-branch }} @ ${{ needs.info.outputs.manifests-commit }}
          Local Branch: ${{ needs.info.outputs.local-branch }} @ ${{ needs.info.outputs.local-commit }}
          
          <details>
            <summary>Tree Status</summary>

            ${{ needs.info.outputs.tree-status }}
          </details>"

  upload-ota:
    needs: [build, package-ota, create-release]
    name: Upload OTA (Test-Keys)
    runs-on: self-hosted
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Check OTA size
        id: check-size
        run: |
          cd -- "${{ inputs.top-dir }}"
          # Check if the OTA size is over 2G, which is the size limit of GitHub Releases.
          OTA_SIZE="$(stat --printf="%s" "${{ needs.package-ota.outputs.ota }}")"
          if (( OTA_SIZE > ${{ inputs.ota-size-limit }} )); then
            echo "::warning title=OTA size too large::ota zip size is $OTA_SIZE, exceeding ${{ inputs.ota-size-limit }}."
            echo "recompress-requested=1" >> "$GITHUB_OUTPUT"
            echo "ota=${{ needs.package-ota.outputs.ota }}.zst" >> "$GITHUB_OUTPUT"
          else
            echo "ota=${{ needs.package-ota.outputs.ota }}" >> "$GITHUB_OUTPUT"
          fi
      - name: Re-Compress OTA
        id: recompress
        if: ${{ steps.check-size.outputs.recompress-requested == '1' }}
        run: |
          cd -- "${{ inputs.top-dir }}"
          # Re-compress OTA package using zstd if it is over 2G.
          # If it is still over 2G, give up uploading to GitHub Releases
          zstd -19 -T8 "${{ needs.package-ota.outputs.ota }}" -o "${{ steps.check-size.outputs.ota }}"
          COMPRESSED_OTA_SIZE="$(stat --printf="%s" "${{ needs.package-ota.outputs.ota }}")"
          if (( COMPRESSED_OTA_SIZE > ${{ inputs.ota-size-limit }} )); then
            echo "::warning title=OTA size still too large after compression::ota zip size is $COMPRESSED_OTA_SIZE, exceeding ${{ inputs.ota-size-limit }}."
            echo "should_upload=0" >> "$GITHUB_OUTPUT"
          else
            echo "should_upload=1" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload to Releases
        if: ${{ steps.recompress.outcome == 'skipped' || steps.recompress.outputs.should_upload == '1' }}
        run: |
          cd -- "${{ inputs.top-dir }}"
          # Upload to GitHub Releases
          # Retry 5 times in case of network failure.
          for i in {1..5}; do
            gh -R "$GITHUB_REPOSITORY" release upload --clobber "${{ needs.create-release.outputs.tag }}" "${{ steps.check-size.outputs.ota }}" && break || sleep 5;
          done

      - name: Upload to Backup Server
        if: ${{ inputs.backup }}
        run: |
          cd -- "${{ inputs.top-dir }}"
          # Upload to Backup Server for Archive
          false # TODO

  announce-ota:
    needs: upload-ota
    name: Announce OTA (Test-Keys)
    runs-on: self-hosted
    steps:
      - name: Update updater
        run: |
          # Update the json for this device.
          # TODO
          true

  # sign:
  #   if: ${{ inputs.sign }}
  #   needs: build
  #   name: Sign the Build
  #   runs-on: self-hosted
  #   steps:
  #     - name: Sign the Build
  #       run: |
  #         # Sign the build based on LineageOS Wiki

  # package-signed-ota:
  #   if: ${{ inputs.sign }}
  #   needs: sign
  #   name: Package OTA (Release-Keys)
  #   runs-on: self-hosted
  
  # create-signed-release:
  #   needs: [build, package-ota]
  #   name: Create Release (Test-Keys)
  #   runs-on: self-hosted
  #   outputs:
  #     tag: ${{ steps.create-release.outputs.tag }}
  #   steps:
  #     - name: Create GitHub Release
  #       id: create-release
  #       run: |
  #         # Create the Release first.
  #         # Retry the upload in case of network failure.
  #         release_tag="${{ inputs.target }}-${{ needs.package-ota.outputs.BUILD_DATE }}"
  #         echp "tag=$release_tag" >> "$GITHUB_OUTPUT"
  #         gh -R "$GITHUB_REPOSITORY" release create "$release_tag" \
  #             -t "${{ needs.package-ota.outputs.BUILD_DATE }} Nightly ${{ needs.package-ota.outputs.PRODUCT_VERSION_MAJOR }}.${{ needs.package-ota.outputs.PRODUCT_VERSION_MINOR }} OTA for ${{ inputs.target }}" \
  #             --notes "OS Branch: ${{ needs.package-ota.outputs.PRODUCT_VERSION_MAJOR }}.${{ needs.package-ota.outputs.PRODUCT_VERSION_MINOR }}
  #         Release Type: Release-Keys
  #         Security Patch: ${{ needs.package-ota.outputs.SECURITY_PATCH }}
  #         Build ID: ${{ needs.package-ota.outputs.BUILD_ID }}"
  #         Build Timestamp: ${{ needs.package-ota.outputs.BUILD_DATE_UTC_TIMESTAMP }}
  #         Product: ${{ needs.build.outputs.TARGET_PRODUCT }}"
  
  # upload-signed-ota:
  #   if: ${{ inputs.sign }}
  #   needs: [package-signed-ota, create-signed-release]
  #   name: Upload OTA (Release-Keys)
  #   runs-on: self-hosted
  
  # announce-signed-ota:
  #   if: ${{ inputs.sign }}
  #   needs: upload-signed-ota
  #   name: Announce OTA (Release-Keys)
  #   runs-on: self-hosted